-TYPE STARTING INCLUDE &FOCINCLUDE
-*-DEFAULT &trgt_tbl=facility_directive_plan_item_equipment_grp, &TRGT_TBL=FACILITY_DIRECTIVE_PLAN_ITEM_EQUIPMENT_GRP
-*-DEFAULT &TTX_SUBJECT=DST,&usr_trgt=dst_facility_directive_plan_item_equipment_grp,&SYNOUT_APP=HISTORICAL_DATA_STORE
-*-DEFAULT &USR_TRGT     = DST_FACILITY_DIRECTIVE_PLAN_ITEM_EQUIPMENT_GRP
-*-DEFAULT &SYN_LEN      = 46
-*-DEFAULT &SYN_NM       = FACILITY_DIRECTIVE_PLAN_ITEM_EQUIPMENT_GRP_SRC
 
 
-*-DEFAULT &trgt_tbl=distribution_participant_conditional_req, &TRGT_TBL=DISTRIBUTION_PARTICIPANT_CONDITIONAL_REQ
-*-DEFAULT &TTX_SUBJECT=DST,&usr_trgt=dst_distribution_participant_conditional_req,&SYNOUT_APP=HISTORICAL_DATA_STORE
-*-DEFAULT &trgt_tbl=railcar, &TRGT_TBL=RAILCAR
-*-DEFAULT &TTX_SUBJECT=AST,&usr_trgt=ast_railcar,&SYNOUT_APP=HISTORICAL_DATA_STORE
-*-DEFAULT &USR_TRGT =' ', &ITERATION_# =' ', &SYN_LEN=' ', &SYN_NM =' '
-*-SET &ECHO=ALL;
-*SET MSG=ON
-*LET 'MSG=OFF' = 'MSG=ON'
-*END
-*-SET &ECHO=ON;
-*-DEFAULT TTX_Subject1='Party' ,
-SET &TTX_Subject=DECODE &TTX_SUBJECT (PTY Party SUP Support FIN Finance MNT Maintenance AST Asset DST Distribution ELSE 'Unknown Subject');
 
APP APPENDPATH HDS_ETL_LOAD
-GOTO GOTABBRS
APP HOLD HDS_ETL_LOAD
TABLE FILE ACD_STD_ABBRV
SUM CNT.STD_ABBRV_CD AS ABBRV_CNT NOPRINT
BY STD_ABBRV_CD
PRINT  E03
BY STD_ABBRV_CD
WHERE TOTAL CNT.STD_ABBRV_CD EQ 1
ON TABLE HOLD AS ACD_STD_ABBRV2 FORMAT FOCUS INDEX STD_ABBRV_CD
END
-EXIT
-GOTABBRS
 
 
 
 
 
 
 
 
-SET &NEW_SEG=&USR_TRGT;
-*SET MSG =ON
 
-*-SET &ECHO=ON;
 
TABLE FILE ETL_ROADMAP
"Iteration: &&ITERATION_TEST"
PRINT TABLE_DESC
 
COMPUTE table_name/A100=LOCASE (100,TABLE_NAME_2, 'A100');
WHERE DATABASE GT ' '
-INCLUDE ETL_PROPOGATE/ROADMAP_FILTER
-*TESTING ONLY
WHERE TOTAL table_name EQ '&trgt_tbl'
 
ON TABLE SET MSG ON

ON TABLE HOLD AS ITERATION1
ON TABLE SET ASNAMES ON
ON TABLE SET HOLDLIST PRINTONLY
END
-*SET MSG = ON
TABLE FILE ITERATION1
PRINT TABLE_DESC
ON TABLE SAVE AS REMARK

END
-RUN
-READ REMARK &TBL_DESC.A68.
-SET &MAP_REMARK= IF &TBL_DESC EQ '.' THEN ' ' ELSE &TBL_DESC;
-SET &RMRK_TXT='REMARK=HDS ' | &TTX_Subject | ':' | &MAP_REMARK;
-TYPE &TBL_DESC
-TYPE &MAP_REMARK
-TYPE &RMRK_TXT

 
TABLE FILE ITERATION1
PRINT table_name
ON TABLE HOLD AS ITERATION
ON TABLE SET ASNAMES ON
ON TABLE SET HOLDLIST PRINTONLY
END
 
 
-GOTO NOLIST
APP PATH HISTORICAL_DATA_STORE
TABLE FILE SYSTABLE
FLIST NAME REAL REMARK
IF NAME EQ (ITERATION)
 
END
 
-EXIT
-NOLIST
FILEDEF TITLE18X DISK TEMP
-SET &NOP = 'NOPRINT ';
-*-SET &NOP = ' ';
-*LET NOPRINT =' '
-*-SET &ECHO=ON;
APP PATH HDS_METADATA  HISTORICAL_DATA_STORE HDS_ETL_LOAD
-*APP HOLD TEST
TABLE FILE SYSCOLUM
PRINT
COMPUTE PATTERN/A78=PATTERN (78, TITLE,  PATTERN); &NOP.EVAL
COMPUTE ABBR?/A1=IF PATTERN CONTAINS 'AA' THEN 'Y' ELSE 'N';
COLNO/A4 NAME/A68 ALIAS/A68 TITLE/A80 LONGDESC
 
-TITLEONLY
COMPUTE TWORD_CNT0/I3=0; &NOP.EVAL
-REPEAT TWORDS FOR &tw FROM 1 TO 18
-*COMPUTE TWORD&tw/A80=IF GETTOK (TITLE, 78, &tw, ',', 78,'A78') GT ' ' THEN
-*                        GETTOK (TITLE, 78, &tw, ',', 78,'A78') ELSE ' ';
COMPUTE TWORD&tw/A80=IF GETTOK (ALIAS, 68, &tw, '_', 68,'A68') GT ' ' THEN
                        GETTOK (ALIAS, 68, &tw, '_', 68,'A68') ELSE ' ';
 
-*-SET &NOP=IF &tw EQ 4 THEN '&NOP.EVAL' ELSE ' ';
-*&NOP.EVAL
-SET &LAST_TCNT=&tw-1;
COMPUTE TWORD_CNT&tw/I3= IF TWORD_CNT&LAST_TCNT EQ 0 THEN (IF TWORD&tw EQ ' ' THEN &LAST_TCNT ELSE 0) ELSE TWORD_CNT&LAST_TCNT; &NOP.EVAL
 
-TWORDS
-GOTO TWORDS2
-*COMPUTE TITLE_REMAINDER/A78=IF GETTOK (TITLE, 78, &tw, ',', 78,'A78') GT ' ' THEN
-*                        GETTOK (TITLE, 78, &tw, ',', 78,'A78') ELSE ' '; NOPRINT
COMPUTE TITLE_REMAINDER/A68=IF GETTOK (ALIAS, 68, &tw, '_', 68,'A68') GT ' ' THEN
                        GETTOK (ALIAS, 68, &tw, '_', 68,'A68') ELSE ' '; NOPRINT
 
-REPEAT TWORDS2 FOR &tw FROM 1 TO 14
-SET &tw3=&tw+4;
-*COMPUTE TWORD&tw3/A80=IF GETTOK (TITLE_REMAINDER, 78, &tw, '_', 78,'A78') GT ' ' THEN
-*                         GETTOK (TITLE_REMAINDER, 78, &tw, '_', 78,'A78') ELSE ' ';
COMPUTE TWORD&tw3/A80=IF GETTOK (TITLE_REMAINDER, 68, &tw, '_', 68,'A68') GT ' ' THEN
                         GETTOK (TITLE_REMAINDER, 68, &tw, '_', 68,'A68') ELSE ' ';
 
-SET &LAST_TCNT=&tw3-1;
COMPUTE TWORD_CNT&tw3/I3= IF TWORD_CNT&LAST_TCNT EQ 0 THEN (IF TWORD&tw3 EQ ' ' THEN &LAST_TCNT ELSE 0) ELSE TWORD_CNT&LAST_TCNT; NOPRINT
-TWORDS2
 
 
-SET &LAST_TCNT=&tw-1;
COMPUTE TWORDCNT/A4=EDIT TWORD_CNT&LAST_TCNT;
-CASEONLY
 
 
-XX
BY TBNAME
 
IF TBNAME EQ (ITERATION)
 
 
 
-*WHERE TBNAME EQ '&syn_nm'
-*WHERE TBNAME IN ('ast_pool','ast_railcar','ast_railcar_equip_profile','dst_flet_seg_partic_dist_enty','dst_flet_seg_partic_rr','dst_railcar_movement','mnt_railcar_maintenance','pty_dist_enty','pty_location','pty_railroad','sup_code','tpty_fac','tpty_org','tpty_pty','tpty_pty_fac','tpty_pty_fac_role','tpty_pty_role','tpty_road','tpty_splc')
 
-*WHERE NAME EQ 'BRAKE_TEST_13MTH_DUE_DT'
-*WHERE ALIAS CONTAINS 'ETL' OR 'AB'
 
ON TABLE HOLD AS TITLE18X FORMAT ALPHA
ON TABLE SET ASNAMES ON
ON TABLE SET HOLDLIST PRINTONLY
ON TABLE SET HOLDATTR FOCUS
END
 
 
FILEDEF TITLE18 DISK TEMP
 
DEFINE FILE TITLE18
-*There were low values as a result of the GETTOK above.
TWORD1/A80=CTRAN (80,TWORD, 00, 32, TWORD1);
PATTERN/A80=PATTERN (80, TWORD1,PATTERN);
UP_TWORD/A80=UPCASE (80, TWORD1, UP_TWORD);
LC_TWORD/A80=LCWORD (80, TWORD1, LC_TWORD);
END
-* Get the TITLEs
 
 
TABLE FILE TITLE18
 
 PRINT TWORD1 NAME ALIAS  COLNO TWORD_SEQ LC_TWORD
-* COMPUTE LEN/I8=ARGLEN (80,UP_TWORD,LEN);
 
-*  COMPUTE LEN2/I8=ARGLEN (80,TWORD1,LEN);
TWORD
 BY UP_TWORD
WHERE TWORD  GT ' '
-*WHERE TBNAME EQ '&syn_nm'
ON TABLE HOLD AS TITLE_WORDS
ON TABLE SET ASNAMES ON
ON TABLE SET HOLDLIST PRINTONLY
END
 
TABLE FILE TITLE_WORDS
 SUM MAX.TWORD_SEQ
ON TABLE SET MSG OFF
ON TABLE SAVE AS MAX_TWORDS
END
 
-RUN
-READ MAX_TWORDS &MAX_TWORD_CNT.I4.
-SET &ALIAS_LEN=(80 * &MAX_TWORD_CNT) + &MAX_TWORD_CNT -1;
 
TABLE FILE CASELIST
 PRINT CASE
 BY UP_WORD
ON TABLE HOLD AS CASE_FOC FORMAT FOCUS INDEX UP_WORD
END
 
-*TABLE FILE TITLE_WORDS
-*PRINT *
-*COMPUTE UP_TWORD2/A100='X' | UP_TWORD | 'X';
-*COMPUTE LEN/I8=ARGLEN (80,UP_TWORD,LEN);
-*WHMERE UP_TWORD CONTAINS 'ETL01'
-*END
-*-EXIT
-*?FF CASE_FOC
-*?FF TITLE_WORDS
-*TABLE FILE CASE_FOC
-*PRINT *
-*COMPUTE UP_TWORDX/A100='X' | UP_WORD | 'X';
-*COMPUTE LEN/I8=ARGLEN (64,UP_WORD,LEN);
-*WHERE UP_WORD CONTAINS 'ETL01'
-*END
 
-*-EXIT
-*SET ALL=ON
JOIN UP_TWORD IN TITLE_WORDS TO UP_WORD IN CASE_FOC
 
TABLE FILE TITLE_WORDS
 
 PRINT  NAME ALIAS COLNO TWORD_SEQ AS TWORD_COUNT
 COMPUTE NEW_ALIAS_TWORD/A80=IF CASE GT ' ' THEN CASE ELSE LC_TWORD;
 
ON TABLE SET ASNAMES ON
ON TABLE SET HOLDLIST PRINTONLY
ON TABLE HOLD AS NEW_ALIAS_TWORDS
END
 
TABLE FILE NEW_ALIAS_TWORDS
 SUM NEW_ALIAS
 BY COLNO
 BY NAME
 ACROSS TWORD_COUNT
 
ON TABLE HOLD AS NEW_TWORDS2
ON TABLE SET ASNAMES ON
END
 
-SET &SAVEECHO=&ECHO;
-*-SET &ECHO=ON;
-RUN
DEFINE FILE NEW_TWORDS2
-SET &IDX=&MAX_TWORD_CNT+1;
-SET &STOPAT=&MAX_TWORD_CNT-1;
NEW_TITLE_PLUS/A&ALIAS_LEN.EVAL=
-REPEAT CONCAT_DEF FOR &C FROM 1 TO &STOPAT
-SET &IDX=&IDX-1;
-SET &IDX2=&IDX;
-SET &NEWS= '   IF NEW' | &IDX | ' GT '' '' THEN NEW1 ' ;
-REPEAT CONCATS FOR &cc FROM 2 TO &IDX2
-IF &cc GT 5 THEN GOTO SPC_DELIM;
-COMMA
-SET &NEWS=&NEWS | '|| '','' || NEW' | &cc;
-GOTO CONCATS
-SPC_DELIM
-SET &NEWS=&NEWS | '|| ( '' '' | NEW' | &cc ;
-CONCATS
-*
-*-TYPE HOW MANY?   &cc
-SET &PAREN_CNT=&cc -6;
-REPEAT CLOSE_PAREN &PAREN_CNT TIMES
-SET &NEWS = &NEWS || ')';
-CLOSE_PAREN
-SET &NEWS= &NEWS | ' ELSE ';
 &NEWS
-CONCAT_DEF
 NEW1;
-*
-* Somehow some low values got stuck in there.
NEW_TITLE_PLUS2/A&ALIAS_LEN.EVAL=CTRAN(&ALIAS_LEN.EVAL,NEW_TITLE_PLUS, 00, 32, NEW_TITLE_PLUS2);
END
 
TABLE FILE NEW_TWORDS2
PRINT NEW_TITLE_PLUS2
 
BY COLNO BY NAME
 
ON TABLE SET MSG OFF
-*ON TABLE PCHOLD FORMAT EXL2K
ON TABLE SAVE AS NEW_TWORDS3
END
-RUN
-SET &COL_CNT=&LINES;
-SET &ECHO=&SAVEECHO;
-*DEFINE FILE NEW_TWORDS2 ADD
-*SHORT/A40=SUBSTR (&ALIAS_LEN.EVAL, NEW_TITLE_PLUS2, 50, 89,40,'A40');
-*END
-*APP PREPENDPATH HDS_ETL_LOAD
-*TABLE FILE TITLE_WORDS PRINT * IF RECORDLIMIT EQ 50
-*END
-*? PATH
SET ALL = ON
JOIN UP_TWORD IN TITLE_WORDS TO  STD_ABBRV_CD IN ACD_STD_ABBRV2 AS J2
END
 
 
TABLE FILE TITLE_WORDS
 PRINT  NAME ALIAS COLNO TWORD_SEQ AS TWORD_COUNT
 
        COMPUTE NEW_DSC_WORD/A80=IF STD_ABBRV_CD EQ ' ' THEN
  (IF CASE GT ' ' THEN CASE      ELSE LC_TWORD) ELSE STD_ABBRV_WORD;
-* BY STD_ABBRV_CD
 
ON TABLE SET ASNAMES ON
ON TABLE SET HOLDLIST PRINTONLY
ON TABLE HOLD AS NEW_DESC_TWORDS
END
 
TABLE FILE NEW_DESC_TWORDS
 SUM NEW_DSC
 BY COLNO
 BY NAME
 ACROSS TWORD_COUNT
 
ON TABLE HOLD AS NEW_DESCS2
ON TABLE SET ASNAMES ON
END
-SET &SAVEECHO=&ECHO;
-*-SET &ECHO=ON;
-RUN
-*-SET &ECHO=ON;
 
DEFINE FILE NEW_DESCS2
-SET &IDX=&MAX_TWORD_CNT+1;
-SET &STOPAT=&MAX_TWORD_CNT-1;
NEW_DESC_PLUS/A&ALIAS_LEN.EVAL=
-REPEAT CONCAT_DEF2 FOR &C2 FROM 1 TO &STOPAT
-SET &IDX=&IDX-1;
-SET &IDX2=&IDX;
-SET &NEWS= '   IF NEW' | &IDX | ' GT '' '' THEN NEW1 ' ;
-REPEAT CONCATS2 FOR &cc2 FROM 2 TO &IDX2
 
-SET &NEWS=&NEWS | '|| ( '' '' | NEW' | &cc2 ;
-CONCATS2
-*
-*-TYPE HOW MANY?   &cc
-SET &PAREN_CNT=&cc2 -2;
-REPEAT CLOSE_PAREN2 &PAREN_CNT TIMES
-SET &NEWS = &NEWS || ')';
-CLOSE_PAREN2
-SET &NEWS= &NEWS | ' ELSE ';
 &NEWS
-CONCAT_DEF2
 NEW1;
-*
-* Somehow some low values got stuck in there.
NEW_DESC_PLUS2/A&ALIAS_LEN.EVAL=CTRAN(&ALIAS_LEN.EVAL,NEW_DESC_PLUS, 00, 32, NEW_DESC_PLUS2);
END
 
TABLE FILE NEW_DESCS2
PRINT NEW_DESC_PLUS2
BY COLNO BY NAME
 
ON TABLE SET MSG ON
 
 
-*ON TABLE PCHOLD FORMAT EXL2K
ON TABLE SAVE AS NEW_DESCS3
END
-RUN
 
-SET &DCOL_CNT=&LINES;
-TYPE LENGTH SHOULD AGREE WITH SAVE PARMS &ALIAS_LEN
-SET &d =;
-*-SET &ECHO=ALL;
-REPEAT DESCS1 FOR &d FROM 1 TO &DCOL_CNT
-READ NEW_DESCS3 NOCLOSE &COLD#.&d.I4. &COLNMD.&d.A68. &DESC.&d.A242.
-*-TYPE &DESC.&d
-*-TYPE NEW_DESCS3 &LINES &d &COLNMD.&d
-DESCS1
-CLOSE NEW_DESCS3
-SET &a = ;
-REPEAT TITLES1 FOR &a FROM 1 TO &COL_CNT
-READ NEW_TWORDS3 NOCLOSE &COL#.&a.I4. &COLNM.&a.A68. &ALIAS.&a.A78.
-*-TYPE NEW_TWORDS3 &COL_CNT &a &COLNM.&a
-TITLES1
-CLOSE NEW_TWORDS3
-*-EXIT
-*-SET &ECHO=ALL;
-SET &UC_String=&TRGT_TBL;
-INCLUDE ETL_PROPOGATE/UPCASE
-*-SET &SRC_SYN=&UC | '_src';
 
APP APPENDPATH ETL_COMMON
-*-SET &SYNSRC_APP = IF &ITERATION_# LT 4 THEN HISTORICAL_DATA_STORE ELSE HDS_METADATA;
-SET &SYNSRC_APP = HDS_METADATA;
-SET &SYNSRC_MFD=&TRGT_TBL || '.mas';
-SET &SYNSRC_PTH=&SYNSRC_APP || '/' || &SYNSRC_MFD;
-SET &SYNOUT_MFD=&usr_trgt || '.mas';
-SET &SYNOUT_PTH=&SYNOUT_APP || '/' || &SYNOUT_MFD;
FILEDEF ANYTEXT DISK &SYNSRC_PTH
-TYPE Source: &SYNSRC_PTH
-TYPE Target: &SYNOUT_PTH
-*-EXIT
FILEDEF SYNOUT DISK &SYNOUT_PTH
 
-INCLUDE ETL_PROPOGATE/ANYTEXT_LEN
 
-SET &F_NM_STR_OLD='FILENAME=' || &TRGT_TBL;
-SET &f_nm_str_old='FILENAME=' || &trgt_tbl;
-SET &F_NM_STR_NEW='FILENAME=' || &NEW_SEG;
-SET &S_NM_STR_OLD='SEGMENT=' || &TRGT_TBL;
-SET &S_NM_STR_NEW='SEGMENT=' || &NEW_SEG;
 
 
-SET &F_STR_LEN=ARGLEN ((&SYN_LEN+9) , &F_NM_STR_OLD , 'I3');
-SET &S_STR_LEN=&F_STR_LEN-1;
 
DEFINE FILE ANYTEXT
-* Change FILENAME= and SEGNAME= to New Seg name
-* STRREP is looking for the keyword prefixed to the file/seg name because the word could appear elsewhere
-* in the MFD and those need to be left alone.
-* I can use "&F_STR_LEN" for both the new and old lengths because '_SRC' and 'DST_' are the same length.
FILE_LINE/A255=STRREP (255, ANYTEXT  , &F_STR_LEN, '&F_NM_STR_OLD', &F_STR_LEN, '&F_NM_STR_NEW' , 255, 'A255');
UP_LINE/A255=STRREP (255, FILE_LINE , &F_STR_LEN, '&f_nm_str_old', &F_STR_LEN, '&F_NM_STR_NEW' , 255, 'A255');
SEG_LINE /A255=STRREP (255, UP_LINE, &S_STR_LEN, '&S_NM_STR_OLD', &S_STR_LEN, '&S_NM_STR_NEW' , 255, 'A255');
END
-*TABLE FILE ANYTEXT PRINT ANYTEXT FILE_LINE SEG_LINE IF READLIMIT EQ 5
-*END
-*-GOTO IN_MFD
 
 
TABLE FILE ANYTEXT
"&SYNSRC_PTH"
"F_STR_LEN &F_STR_LEN"
"&SYN_NM"
"&NEW_SEG"
 PRINT SEG_LINE
 
ON TABLE SET MSG OFF
 
ON TABLE SAVE AS INSYN
END
-*SAVE AS INSYN
-RUN
-SET &SYN_LINE_CNT= &LINES;
 
 
 
-SET &T_WHERE? = 'B';
-SET &TRIM_IN=&SYN_LINE_CNT;
-INCLUDE ETL_PROPOGATE/TRIM_IT
-SET &SYN_LINE_CNT=&TRIMMED;
-SET &ALIAS_IDX=0;
-SET &SEGMENT_FND=0;
-SET &HDR_DONE=N;
-SET &hdr#=0;
-SET &hdr_out#=0;
-SET &REMARK_LOC=0;
-SET &rmrk_line=0;
-SET &BREAK_LINE?=N;
-SET &OLD_RMRK_TXT = ' ';
-SET &ADMIN_COLS='N';
 
-*-? &
-*-EXIT
-REPEAT IN_MFD FOR &in FROM 1 TO &SYN_LINE_CNT
 
-READ INSYN NOCLOSE &SYNTEXT.A&MAX_LINE_LEN.EVAL
-SET &LEN=ARGLEN (&MAX_LINE_LEN, &SYNTEXT, 'I4');
-IF &LEN EQ 0 THEN GOTO WRITELINE;
-IF &SEGMENT_FND GT 0 THEN GOTO NORMAL_LINES;
-*-SET &ECHO=ALL;
-SET &P_String=&SYNTEXT;
-SET &P_char='SEGMENT=';
-INCLUDE ETL_PROPOGATE/POSIT
-SET &SEGMENT_FND=IF &P_LOC GT 0 THEN &P_LOC ELSE &SEGMENT_FND;
-*-TYPE INPUT 888888888888888 &SYNTEXT
-IF &SEGMENT_FND GT 0 AND &HDR_DONE EQ Y THEN GOTO NORMAL_LINES;
 
-IF &SEGMENT_FND GT 0 THEN GOTO WRITE_HDR;
-SET &hdr#=&hdr#+1;
 
 
-* This section (to -RMRK_FND) looks for either REMARK or REMARKS
-SET &P_String=&SYNTEXT;
-SET &P_char='REMARK=';
-INCLUDE ETL_PROPOGATE/POSIT
-SET &rmrk_line = IF &P_LOC GT 0 THEN &hdr# ELSE 0;
-IF &rmrk_line GT 0 THEN GOTO RMRK_FND;
-SET &P_char='REMARKS=';
-INCLUDE ETL_PROPOGATE/POSIT
-SET &rmrk_line = IF &P_LOC GT 0 THEN &hdr# ELSE 0;
 
-RMRK_FND
 
 
 
 
 
 
-SET &REMARK_LOC=IF &rmrk_line GT 0 THEN &P_LOC ELSE &REMARK_LOC;
-SET &HDR.&hdr#=&SYNTEXT;
-GOTO IN_MFD
 
-WRITE_HDR
 
-*-TYPE Total Hdr lines:&hdr# REMRK LIN: &rmrk_line LOC &REMARK_LOC
 
 
-REPEAT DO_HDR FOR &dh FROM 1 TO &hdr#
-*-TYPE HDR PROCESSING +++++++++++++++ &HDR.&dh
 
 
-* IF &dh NE &rmrk_line OR &hdr#  means that it's neither a REMARK or the last line
-*  (which contains the "$"
-*-TYPE &dh &rmrk_line &hdr#
-SET &TEXT_LEN=ARGLEN (&HDR.&dh.LENGTH, &HDR.&dh, 'I4');
-SET &ONE_BACK=&TEXT_LEN -1 ;
-SET &hdr_out# = &hdr_out# + 1;
-SET &HDR.&dh = IF &dh EQ &hdr# THEN SUBSTR ( &TEXT_LEN, &HDR.&dh, 1, &ONE_BACK, &ONE_BACK, 'A&ONE_BACK.EVAL')
-               ELSE &HDR.&dh;
 
-*-SET &HDR.&dh = IF &dh EQ &hdr# THEN SUBSTR ( &TEXT_LEN, &HDR.&dh, 1, &ONE_BACK, &ONE_BACK, 'A&ONE_BACK.EVAL')
-*-               ELSE &HDR.&dh;
 
-SET &RMRK_LEN=ARGLEN (&RMRK_TXT.LENGTH, &RMRK_TXT, 'I4');
-SET &REMARK_LEN=IF &rmrk_line NE &dh THEN 0 ELSE &HDR.&dh.LENGTH - &REMARK_LOC;
-*SET &BREAK_LINE? = IF &REMARK_LOC GT 5 THEN 'Y' ELSE 'N';
-*-TYPE Remark Loc:&REMARK_LOC Remark Len: &REMARK_LEN  &HDR.&dh
-*-SET &ECHO=ALL;
-SET &H_LEN=ARGLEN (&HDR.&dh.LENGTH, &HDR.&dh, 'I3');
-SET &ONEBACK=IF &rmrk_line EQ &dh THEN &REMARK_LOC-1 ELSE &H_LEN;
-*-SET &hdr_out# = &hdr_out# + 1;
-SET &OUTHDR.&hdr_out#=  SUBSTR (&TEXT_LEN, &HDR.&dh, 1, &ONEBACK, &ONEBACK, 'A&ONEBACK.EVAL');
 
-*-TYPE XXXXXXXXXXX &OUTHDR.&hdr_out# ..........
-*-SET &ECHO=OFF;
 
 
-IF &REMARK_LOC EQ 0 THEN GOTO NORMRK1;
-IF &rmrk_line NE &dh THEN GOTO NORMRK2;
-SET &OLD_RMRK_TXT=SUBSTR (&TEXT_LEN, &HDR.&dh, &REMARK_LOC,&TEXT_LEN, &REMARK_LEN, 'A&REMARK_LEN.EVAL');
-*-TYPE THIS IS THE RERMAKR: &OLD_RMRK_TXT
-*SET &hdr_out# = IF &REMARK_LEN GT 16 THEN &hdr_out# + 1 ELSE &hdr_out#;
-SET &OUTHDR.&hdr_out#=&RMRK_TXT;
-TYPE  xxxx  &OUTHDR.&hdr_out#
-*-SET &OUTHDR.&hdr_out#=IF &REMARK_LEN LE 16 THEN &RMRK_TXT ELSE &OLD_RMRK_TXT;
-GOTO NORMRK99
-NORMRK1
-*-TYPE NORMRK1
-SET &hdr_out#=&hdr_out#+1;
-SET &OUTHDR.&hdr_out# =&RMRK_TXT;
-*IF &REMARK_LEN LE 16 THEN &RMRK_TXT  ELSE &OLD_RMRK_TXT;
-GOTO NORMRK99
-NORMRK2
-*-TYPE NORMRK2 - NOT YET
-NORMRK99
 
-DO_HDR
 
 
 
-REPEAT HDR_OUT FOR &h FROM 1 TO &hdr_out#
-SET &TERMINATE=IF &h EQ &hdr_out# THEN ',$' ELSE ', ';
-SET &O_LEN=ARGLEN ( &OUTHDR.&h.LENGTH, &OUTHDR.&h, 'I4');
-SET &OUTHDR.&h = STRREP (&O_LEN, &OUTHDR.&h, 8, 'REMARKS=',7, 'REMARK=',&O_LEN, 'A&O_LEN.EVAL');
 
-SET &OUTHDR.&h = &OUTHDR.&h || &TERMINATE;
-TYPE HDR @ WRITE    &OUTHDR.&h
 
-WRITE SYNOUT NOCLOSE &OUTHDR.&h
-HDR_OUT
 
-SET &HDR_DONE = Y;
 
 
-*-GOTO NORMAL_LINES
-WRITE SYNOUT NOCLOSE &SYNTEXT
-GOTO IN_MFD
 
 
-NORMAL_LINES
 
-SET &P_String=&SYNTEXT;
 
-* It is assumed that all 4 admin columns follow the hashbyte and that they are
-*  the last cols of the mfd.
-SET &P_char='FIELDNAME=FULL_HASHBYTE';
 
-INCLUDE ETL_PROPOGATE/POSIT
 
-SET &ADMIN_COLS= IF &ADMIN_COLS EQ Y THEN Y ELSE IF &P_LOC GT 0 THEN 'Y' ELSE 'N';
-IF &ADMIN_COLS EQ Y THEN GOTO IN_MFD;
-*-TYPE NORMAL &ADMIN_COLS &SYNTEXT
-SET &LAST_CHAR=SUBSTR (&P_S_LEN, &SYNTEXT, &P_S_LEN, &P_S_LEN, 1, 'A1');
-IF EDIT ((LJUST (&P_S_LEN, &SYNTEXT, 'A&P_S_LEN.EVAL')), '9') EQ '$' THEN GOTO WRITELINE;
 
-*-TYPE LOOKING FOR $ &SYNTEXT
-SET &P_String=&SYNTEXT;
-SET &P_char='$';
-IF &LAST_CHAR NE '$' THEN GOTO WRITELINE;
 
-SET &ALIAS_IDX=&ALIAS_IDX+1;
-SET &SR_string=&SYNTEXT;
-SET &SR_len = ARGLEN (&SR_string.LENGTH, &SR_string, 'I4');
-*-SET &ECHO=ALL;
-SET &NEW_len= ARGLEN (&ALIAS.&ALIAS_IDX.LENGTH, &ALIAS.&ALIAS_IDX, 'I4');
 
-SET &NEW_string=LJUST (&NEW_len, &ALIAS.&ALIAS_IDX , 'A&NEW_len.EVAL');
-SET &NEW_alias='TITLE=''' || &NEW_string || ''',';
-*-SET &ECHO=OFF;
-*-TYPE FOUND $ ALIAS_IDX=&ALIAS_IDX &SYNTEXT
-SET &P_char='TITLE=';
 
-INCLUDE ETL_PROPOGATE/POSIT
-SET &TITLE_LOC=IF &P_LOC GT 0 THEN &P_LOC ELSE 0;
-IF &TITLE_LOC GT 0 THEN GOTO HAVETITLE;
-*-TYPE MAKE TITLE from &NEW_alias
-SET &NEW_LEN=&SR_len + &NEW_alias.LENGTH -1;
-SET &SYNTEXT=STRREP (&SR_len, &SR_string, 1,'$' , &NEW_alias.LENGTH, &NEW_alias   ,&NEW_LEN, 'A&NEW_LEN.EVAL');
-* Strip the $
-*SET &StLen=ARGLEN (&SYNTEXT.LENGTH, &SYNTEXT, 'I4');
-*SET &ONEless=&StLen-1;
-*SET &DOLLAR?=SUBSTR (&StLen, &SYNTEXT, &StLen, &StLen, 1, 'A1');
-*TYPE &NEW_alias
-*IF &DOLLAR? NE '$' THEN GOTO WRITELINE;
-*SET &SYNTEXT=SUBSTR (&StLen, &SYNTEXT, 1, &ONEless, &ONEless, 'A&ONEless.EVAL');
-WRITE SYNOUT NOCLOSE &SYNTEXT
-*-SET &DESC_string= CTRAN(&NEW_len, &NEW_string, 44, 32, 'A&NEW_len.EVAL');
-*-TYPE DESCRIPTION: &DESC.&ALIAS_IDX
-SET &SYNTEXT='      DESC=''' | &DESC.&ALIAS_IDX || ''',$ ';
-GOTO WRITELINE
-HAVETITLE
 
-*-TYPE The TITLE is in here old: &ALIAS.&ALIAS_IDX
-*-TYPE The TITLE is in here new:&NEW_alias
-*-TYPE &NEW_string
-SET &UC_String= &NEW_string;
-SET &UC_S_LEN=ARGLEN (&UC_String.LENGTH, &UC_String, 'I4');
-SET &UC      = LCWORD(&UC_S_LEN, &UC_String , 'A&UC_S_LEN.EVAL');
 
 
-SET &OLD_alias= &UC;
 
-SET &SR_string2=STRREP (&SR_len, &SR_string, &OLD_alias.LENGTH, &OLD_alias , &NEW_string.LENGTH, &NEW_string,&SR_len, 'A&SR_len.EVAL');
 
-SET &SR_string=&SR_string2;
-*-TYPE ##### &ALIAS_IDX @@@&OLD_alias @@@&NEW_alias @@@
-*-SET &SR_len = ARGLEN (&SR_string.LENGTH, &SR_string, 'I4');
-*-SET &OLD_string=' FIELDTYPE=R,';
-*-SET &NEW_string=' ';
-*-SET &NEW_len=&SR_len - &OLD_string.LENGTH+1;
 
-*-SET &SR_string2=STRREP (&SR_len, &SR_string, &OLD_string.LENGTH, &OLD_string , 1, ' X'   ,&NEW_len, 'A&NEW_len.EVAL');
-SET &SYNTEXT = &SR_string2;
-WRITE SYNOUT NOCLOSE &SR_string2
-SET &SYNTEXT='    DESC='' '',$ ';
-WRITELINE
-*-TYPE WRITING OUT &SYNTEXT
-WRITE SYNOUT NOCLOSE &SYNTEXT
-*-IF &in GT 1 THEN GOTO IN_MFD;
-*-WRITE SYNOUT NOCLOSE   REMARKS=HDS ,$
-*-TYPE **
-*-SET &ECHO=OFF;
-IN_MFD
-SET &ECHO=OFF;
-CLOSE SYNOUT
-defs
-*-? &
-TYPE ENDING INCLUDE &FOCINCLUDE
